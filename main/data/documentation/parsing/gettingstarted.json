{"hierarchy":{"paths":[["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing"]]},"abstract":[{"text":"Learn how to integrate Parsing into your project and write your first parser.","type":"text"}],"seeAlsoSections":[{"title":"Articles","identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Design","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/StringAbstractions","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ErrorMessages","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Backtracking"],"generated":true}],"kind":"article","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/parsing\/gettingstarted"]}],"schemaVersion":{"major":0,"patch":0,"minor":2},"sections":[],"metadata":{"role":"article","title":"Getting Started","roleHeading":"Article","modules":[{"name":"Parsing"}]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/GettingStarted"},"primaryContentSections":[{"content":[{"anchor":"Adding-Parsing-as-a-dependency","text":"Adding Parsing as a dependency","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"To use the Parsing library in a SwiftPM project, add it to the dependencies of your Package.swift","type":"text"},{"text":" ","type":"text"},{"text":"and specify the ","type":"text"},{"code":"Parsing","type":"codeVoice"},{"text":" product in any targets that need access to the library:","type":"text"}]},{"code":["let package = Package(","  dependencies: [","    .package(url: \"https:\/\/github.com\/pointfreeco\/swift-parsing\", from: \"0.7.0\"),","  ],","  targets: [","    .target(","      name: \"<target-name>\",","      dependencies: [.product(name: \"Parsing\", package: \"swift-parsing\")]","    )","  ]",")"],"type":"codeListing","syntax":"swift"},{"anchor":"Your-first-parser","text":"Your first parser","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"Suppose you have a string that holds some user data that you want to parse into an array of ","type":"text"},{"code":"User","type":"codeVoice"},{"text":"s:","type":"text"}]},{"code":["let input = \"\"\"","  1,Blob,true","  2,Blob Jr.,false","  3,Blob Sr.,true","  \"\"\"","","struct User {","  var id: Int","  var name: String","  var isAdmin: Bool","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A naive approach to this would be a nested use of "},{"type":"codeVoice","code":".split(separator:)"},{"type":"text","text":", and then a little bit of"},{"type":"text","text":" "},{"type":"text","text":"extra work to convert strings into integers and booleans:"}]},{"code":["let users = input","  .split(separator: \"\\n\")","  .compactMap { row -> User? in","    let fields = row.split(separator: \",\")","    guard","      fields.count == 3,","      let id = Int(fields[0]),","      let isAdmin = Bool(String(fields[2]))","    else { return nil }","","    return User(id: id, name: String(fields[1]), isAdmin: isAdmin)","  }"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Not only is this code a little messy, but it is also inefficient since we are allocating arrays for"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":".split"},{"type":"text","text":" and then just immediately throwing away those values."}]},{"type":"paragraph","inlineContent":[{"text":"It would be more straightforward and efficient to instead describe how to consume bits from the","type":"text"},{"text":" ","type":"text"},{"text":"beginning of the input and convert that into users. This is what this parser library excels at ðŸ˜„.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can start by describing what it means to parse a single row, first by parsing an integer off the"},{"type":"text","text":" "},{"type":"text","text":"front of the string, and then parsing a comma. We can do this by using the "},{"type":"codeVoice","code":"Parse"},{"type":"text","text":" type, which acts"},{"type":"text","text":" "},{"type":"text","text":"as an entry point into describing a list of parsers that you want to run one after the other to"},{"type":"text","text":" "},{"type":"text","text":"consume from an input:"}]},{"code":["let user = Parse {","  Int.parser()","  \",\"","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Already this can consume the leading integer and comma from the beginning of the input:"}]},{"code":["\/\/ Use a mutable substring to verify what is consumed","var input = input[...]","","try user.parse(&input)  \/\/ 1","input                   \/\/ \"Blob,true\\n2,Blob Jr.,false\\n3,Blob Sr.,true\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Next we want to take everything up until the next comma for the userâ€™s name, and then consume the","type":"text"},{"text":" ","type":"text"},{"text":"comma:","type":"text"}]},{"code":["let user = Parse {","  Int.parser()","  \",\"","  Prefix { $0 != \",\" }","  \",\"","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"And then we want to take the boolean at the end of the row for the userâ€™s admin status:","type":"text"}]},{"code":["let user = Parse {","  Int.parser()","  \",\"","  Prefix { $0 != \",\" }","  \",\"","  Bool.parser()","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Currently this will parse a tuple "},{"type":"codeVoice","code":"(Int, Substring, Bool)"},{"type":"text","text":" from the input, and we can "},{"type":"codeVoice","code":".map"},{"type":"text","text":" on"},{"type":"text","text":" "},{"type":"text","text":"that to turn it into a "},{"type":"codeVoice","code":"User"},{"type":"text","text":":"}]},{"code":["let user = Parse {","  Int.parser()","  \",\"","  Prefix { $0 != \",\" }","  \",\"","  Bool.parser()","}",".map { User(id: $0, name: String($1), isAdmin: $2) }"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"To make the data we are parsing to more prominent, we can instead pass the transform closure as the","type":"text"},{"text":" ","type":"text"},{"text":"first argument to ","type":"text"},{"code":"Parse","type":"codeVoice"},{"text":":","type":"text"}]},{"code":["let user = Parse {","  User(id: $0, name: String($1), isAdmin: $2)","} with: {","  Int.parser()","  \",\"","  Prefix { $0 != \",\" }","  \",\"","  Bool.parser()","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Or we can pass the ","type":"text"},{"code":"User","type":"codeVoice"},{"text":" initializer to ","type":"text"},{"code":"Parse","type":"codeVoice"},{"text":" in a point-free style by first transforming the","type":"text"},{"text":" ","type":"text"},{"code":"Prefix","type":"codeVoice"},{"text":" parserâ€™s output from a ","type":"text"},{"code":"Substring","type":"codeVoice"},{"text":" to a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":":","type":"text"}]},{"code":["let user = Parse(User.init(id:name:isAdmin:)) {","  Int.parser()","  \",\"","  Prefix { $0 != \",\" }.map(String.init)","  \",\"","  Bool.parser()","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"That is enough to parse a single user from the input string, leaving behind a newline and the final","type":"text"},{"text":" ","type":"text"},{"text":"two users:","type":"text"}]},{"code":["try user.parse(&input) \/\/ User(id: 1, name: \"Blob\", isAdmin: true)","input \/\/ \"\\n2,Blob Jr.,false\\n3,Blob Sr.,true\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"To parse multiple users from the input we can use the ","type":"text"},{"code":"Many","type":"codeVoice"},{"text":" parser to run the user parser many","type":"text"},{"text":" ","type":"text"},{"text":"times:","type":"text"}]},{"code":["let users = Many {","  user","} separator: {","  \"\\n\"","}","","try users.parse(&input) \/\/ [User(id: 1, name: \"Blob\", isAdmin: true), ...]","input \/\/ \"\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now this parser can process an entire document of users, and the code is simpler and more"},{"type":"text","text":" "},{"type":"text","text":"straightforward than the version that uses "},{"type":"codeVoice","code":".split"},{"type":"text","text":" and "},{"type":"codeVoice","code":".compactMap"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Even better, itâ€™s more performant. Weâ€™ve written "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/pointfreeco\/swift-parsing\/blob\/main\/Sources\/swift-parsing-benchmark\/ReadmeExample.swift"},{"type":"text","text":" for these two"},{"type":"text","text":" "},{"type":"text","text":"styles of parsing, and the "},{"type":"codeVoice","code":".split"},{"type":"text","text":"-style of parsing is more than twice as slow:"}]},{"code":["name                             time        std        iterations","------------------------------------------------------------------","README Example.Parser: Substring 3426.000 ns Â±  63.40 %     385395","README Example.Ad hoc            7631.000 ns Â±  47.01 %     169332"],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"text":"Further, if you are willing write your parsers against ","type":"text"},{"code":"UTF8View","type":"codeVoice"},{"text":" instead of ","type":"text"},{"code":"Substring","type":"codeVoice"},{"text":", you can","type":"text"},{"text":" ","type":"text"},{"text":"eke out even more performance, more than doubling the speed:","type":"text"}]},{"code":["name                             time        std        iterations","------------------------------------------------------------------","README Example.Parser: Substring 3693.000 ns Â±  81.76 %     349763","README Example.Parser: UTF8      1272.000 ns Â± 128.16 %     999150","README Example.Ad hoc            8504.000 ns Â±  59.59 %     151417"],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"text":"See the article ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/StringAbstractions"},{"text":" for more info on how to write parsers against different","type":"text"},{"text":" ","type":"text"},{"text":"string abstraction levels.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can also compare these times to a tool that Appleâ€™s Foundation gives us: "},{"code":"Scanner","type":"codeVoice"},{"type":"text","text":". Itâ€™s a type"},{"type":"text","text":" "},{"type":"text","text":"that allows you to consume from the beginning of strings in order to produce values, and provides"},{"type":"text","text":" "},{"type":"text","text":"a nicer API than using "},{"code":".split","type":"codeVoice"},{"type":"text","text":":"}]},{"code":["var users: [User] = []","while scanner.currentIndex != input.endIndex {","  guard","    let id = scanner.scanInt(),","    let _ = scanner.scanString(\",\"),","    let name = scanner.scanUpToString(\",\"),","    let _ = scanner.scanString(\",\"),","    let isAdmin = scanner.scanBool()","  else { break }","","  users.append(User(id: id, name: name, isAdmin: isAdmin))","  _ = scanner.scanString(\"\\n\")","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, the "},{"type":"codeVoice","code":"Scanner"},{"type":"text","text":" style of parsing is more than 5 times as slow as the substring parser written"},{"type":"text","text":" "},{"type":"text","text":"written above, and more than 15 times slower than the UTF-8 parser:"}]},{"code":["name                             time         std        iterations","-------------------------------------------------------------------","README Example.Parser: Substring  3481.000 ns Â±  65.04 %     376525","README Example.Parser: UTF8       1207.000 ns Â± 110.96 %    1000000","README Example.Ad hoc             8029.000 ns Â±  44.44 %     163719","README Example.Scanner           19786.000 ns Â±  35.26 %      62125"],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"Not only are parsers built with the library more succinct and many times more performant than ad hoc"},{"type":"text","text":" "},{"type":"text","text":"parsers, but they can also be easier to evolve to accommodate more features. For example, right now"},{"type":"text","text":" "},{"type":"text","text":"our parser does not work correctly when the userâ€™s name contains a comma, such as â€œBlob, Esq.â€:"}]},{"code":["try user.parse(\"1,Blob, Esq.,true\")","","\/\/ error: unexpected input","\/\/  --> input:1:8","\/\/ 1 | 1,Blob, Esq.,true","\/\/   |        ^ expected \"true\" or \"false\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The problem is that we are using the comma as a reserved identifier for delineating between fields,"},{"type":"text","text":" "},{"type":"text","text":"and so a field cannot contain a comma. We can enhance the CSV format to allow for quoting fields"},{"type":"text","text":" "},{"type":"text","text":"so that they can contain quotes:"}]},{"code":["1,\"Blob, Esq.\",true"],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"To parse quoted fields we can first try parsing a quote, then everything up to the next quote, and"},{"type":"text","text":" "},{"type":"text","text":"then the trailing quote:"}]},{"code":["let quotedField = Parse {","  \"\\\"\"","  Prefix { $0 != \"\\\"\" }","  \"\\\"\"","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"And then to parse a field, in general, we can first try parsing a quoted field, and if that fails we","type":"text"},{"text":" ","type":"text"},{"text":"will just take everything until the next comma. We can do this using the ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf","isActive":true,"type":"reference"},{"text":" parser, which","type":"text"},{"text":" ","type":"text"},{"text":"allows us to run multiple parsers on the same input, and it will take the first that succeeds:","type":"text"}]},{"code":["let field = OneOf {","  quotedField","  Prefix { $0 != \",\" }","}",".map(String.init)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"We can use this parser in the ","type":"text"},{"code":"user","type":"codeVoice"},{"text":" parser, and now it properly handles quoted and non-quoted","type":"text"},{"text":" ","type":"text"},{"text":"fields:","type":"text"}]},{"code":["let user = Parse(User.init) {","  Int.parser()","  \",\"","  field","  \",\"","  Bool.parser()","}","","try user.parse(\"1,\"Blob, Esq.\",true\") \/\/ User(id: 1, name: \"Blob, Esq.\", admin: true)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It was quite straightforward to improve the "},{"code":"user","type":"codeVoice"},{"type":"text","text":" parser to handle quoted fields. Doing the same"},{"type":"text","text":" "},{"type":"text","text":"with our ad hoc "},{"code":"split","type":"codeVoice"},{"type":"text","text":"\/"},{"code":"compactMap","type":"codeVoice"},{"type":"text","text":" parser, and even the "},{"code":"Scanner","type":"codeVoice"},{"type":"text","text":"-based parser, would be a lot"},{"type":"text","text":" "},{"type":"text","text":"more difficult."}]},{"type":"paragraph","inlineContent":[{"text":"Thatâ€™s the basics of parsing a simple string format, but thereâ€™s a lot more operators and tricks to","type":"text"},{"text":" ","type":"text"},{"text":"learn in order to performantly parse larger inputs. View the ","type":"text"},{"type":"reference","identifier":"https:\/\/github.com\/pointfreeco\/swift-parsing\/tree\/main\/Sources\/swift-parsing-benchmark","isActive":true},{"text":" for examples","type":"text"},{"text":" ","type":"text"},{"text":"of real-life parsing scenarios.","type":"text"}]}],"kind":"content"}],"references":{"doc://co.pointfree.Parsing/documentation/Parsing/Design":{"url":"\/documentation\/parsing\/design","kind":"article","title":"Design","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Design","abstract":[{"text":"Learn how the library is designed, including its use of protocols, result builders and operators.","type":"text"}],"type":"topic","role":"article"},"doc://co.pointfree.Parsing/documentation/Parsing/StringAbstractions":{"url":"\/documentation\/parsing\/stringabstractions","kind":"article","title":"String Abstractions","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/StringAbstractions","abstract":[{"text":"Learn how to write parsers on different levels of string abstractions, giving you the ability to","type":"text"},{"text":" ","type":"text"},{"text":"trade performance for correctness where needed.","type":"text"}],"type":"topic","role":"article"},"doc://co.pointfree.Parsing/documentation/Parsing/ErrorMessages":{"role":"article","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ErrorMessages","abstract":[{"type":"text","text":"Learn how the library reports parsing errors and how to integrate your own custom error messages"},{"type":"text","text":" "},{"type":"text","text":"into parsers."}],"url":"\/documentation\/parsing\/errormessages","type":"topic","title":"Error messages","kind":"article"},"doc://co.pointfree.Parsing/documentation/Parsing":{"abstract":[{"type":"text","text":"A library for turning nebulous data into well-structured data, with a focus on composition,"},{"type":"text","text":" "},{"type":"text","text":"performance, generality, and ergonomics."}],"url":"\/documentation\/parsing","title":"Parsing","role":"collection","kind":"symbol","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing","type":"topic"},"doc://co.pointfree.Parsing/documentation/Parsing/Backtracking":{"url":"\/documentation\/parsing\/backtracking","kind":"article","title":"Backtracking","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Backtracking","abstract":[{"text":"Learn what backtracking is, how it affects the performance of your parsers, and how to avoid it when","type":"text"},{"text":" ","type":"text"},{"text":"unnecessary.","type":"text"}],"type":"topic","role":"article"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf":{"type":"topic","title":"OneOf","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OneOf","kind":"identifier"}],"navigatorTitle":[{"text":"OneOf","kind":"identifier"}],"url":"\/documentation\/parsing\/oneof","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf","abstract":[{"type":"text","text":"A parser that attempts to run a number of parsers till one succeeds."}],"role":"symbol"},"https://github.com/pointfreeco/swift-parsing/blob/main/Sources/swift-parsing-benchmark/ReadmeExample.swift":{"titleInlineContent":[{"text":"benchmarks","type":"text"}],"type":"link","identifier":"https:\/\/github.com\/pointfreeco\/swift-parsing\/blob\/main\/Sources\/swift-parsing-benchmark\/ReadmeExample.swift","url":"https:\/\/github.com\/pointfreeco\/swift-parsing\/blob\/main\/Sources\/swift-parsing-benchmark\/ReadmeExample.swift","title":"benchmarks"},"https://github.com/pointfreeco/swift-parsing/tree/main/Sources/swift-parsing-benchmark":{"titleInlineContent":[{"text":"benchmarks","type":"text"}],"type":"link","identifier":"https:\/\/github.com\/pointfreeco\/swift-parsing\/tree\/main\/Sources\/swift-parsing-benchmark","url":"https:\/\/github.com\/pointfreeco\/swift-parsing\/tree\/main\/Sources\/swift-parsing-benchmark","title":"benchmarks"}}}